The following is a digest of the repository "ft_irc.git".
This digest is designed to be easily parsed by Large Language Models.

--- SUMMARY ---
Repository: ft_irc.git
Files Analyzed: 21
Total Text Size: 86.6 KB
Estimated Tokens (text only): ~21,239

--- DIRECTORY STRUCTURE ---
ft_irc.git/
├── includes/
│   ├── Channel.hpp
│   ├── Client.hpp
│   ├── Command.hpp
│   ├── CommandHandlers.hpp
│   ├── IRCProtocol.hpp
│   ├── Server.hpp
│   └── utils.hpp
├── srcs/
│   ├── Channel.cpp
│   ├── Client.cpp
│   ├── Command.cpp
│   ├── CommandHandlers.cpp
│   ├── IRCProtocol.cpp
│   ├── Server.cpp
│   └── utils.cpp
├── CLAUDE.md
├── main.cpp
├── Makefile
├── README.md
├── test_main.cpp
├── test_server.cpp
└── test.cpp


--- FILE CONTENTS ---
============================================================
FILE: includes/Channel.hpp
============================================================
#ifndef CHANNEL_HPP
#define CHANNEL_HPP

#include <string>
#include <set>
#include <map>

class Client; // Forward declaration

class Channel {
private:
    std::string _name;
    std::string _topic;
    std::set<Client*> _members;
    std::set<Client*> _operators;
    
    // Channel modes
    bool _inviteOnly;      // +i mode
    bool _topicRestricted; // +t mode
    std::string _key;      // +k mode (password)
    size_t _userLimit;     // +l mode (0 = no limit)
    
    // Invite list (simple session-based)
    std::set<Client*> _invitedClients;

public:
    Channel(const std::string& name);
    ~Channel();

    // Basic info
    const std::string& getName() const;
    const std::string& getTopic() const;
    void setTopic(const std::string& topic);

    // Membership
    void addClient(Client* client);
    void removeClient(Client* client);
    bool hasClient(Client* client) const;
    const std::set<Client*>& getMembers() const;


    // Operators
    void addOperator(Client* client);
    void removeOperator(Client* client);
    bool isOperator(Client* client) const;

    // Messaging
    void broadcast(const std::string& message, Client* sender);
    
    // Modes
    bool isInviteOnly() const;
    bool isTopicRestricted() const;
    const std::string& getKey() const;
    size_t getUserLimit() const;
    
    void setInviteOnly(bool inviteOnly);
    void setTopicRestricted(bool topicRestricted);
    void setKey(const std::string& key);
    void setUserLimit(size_t limit);
    
    std::string getModeString() const;
    
    // Invite management
    void addInvite(Client* client);
    void removeInvite(Client* client);
    bool isInvited(Client* client) const;
};

#endif


============================================================
FILE: includes/Client.hpp
============================================================
#ifndef CLIENT_HPP
#define CLIENT_HPP

#include <string>
#include <deque>
#include <ctime>

class Client {
private:
    int _fd;
    std::string _nickname;
    std::string _username;
    std::string _realname;
    std::string _hostname;
    bool _receivedPass;
    bool _receivedNick;
    bool _receivedUser;
    bool _registered;

    std::string _inputBuffer;
    std::string _outputBuffer;
    std::deque<std::string> _outBufQ;  // Message queue for better I/O handling
    time_t _lastActive;                // For timeout tracking

public:
    Client(int fd);
    ~Client();

    // Getters
    int getFd() const;
    const std::string& getNickname() const;
    const std::string& getUsername() const;
    const std::string& getRealname() const;
    const std::string& getHostname() const;
    std::string getHostmask() const;
    bool isRegistered() const;
    time_t getLastActive() const;

    // Setters
    void setNickname(const std::string& nick);
    void setUsername(const std::string& user);
    void setRealname(const std::string& realname);
    void setHostname(const std::string& hostname);
    void setReceivedPass(bool);
    void setReceivedNick(bool);
    void setReceivedUser(bool);
    void tryRegister();
    void updateLastActive();

    // Buffers
    void appendToInputBuffer(const std::string& data);
    std::string& getInputBuffer();
    std::string& getOutputBuffer();

    // Message queue handling
    void enqueueMessage(const std::string& message);
    bool hasMessagesToSend() const;
    void flushMessagesToOutputBuffer();

    // Line extraction for IRC command parsing
    std::string extractNextLine();
    bool hasCompleteLine() const;
};

#endif


============================================================
FILE: includes/Command.hpp
============================================================
#ifndef COMMAND_HPP
#define COMMAND_HPP

#include <string>
#include <vector>
#include <map>
#include "Client.hpp"
#include "Server.hpp"
#include "CommandHandlers.hpp"
#include "IRCProtocol.hpp"

class Server; // Forward declaration
class Client; // Forward declaration
class CommandHandlers; // Forward declaration

class Command {
private:
    Server* _server;
    CommandHandlers* _handlers;
    std::map<std::string, void (CommandHandlers::*)(Client*, const std::vector<std::string>&)> _commandMap;

    void initializeCommandMap();
    IRCCommand parseRawCommand(const std::string& rawCommand);
    std::vector<std::string> splitParams(const std::string& params);

public:
    Command(Server* server);
    ~Command();

    // Main command processing
    void processClientBuffer(Client* client);
    void executeCommand(Client* client, const IRCCommand& cmd);

    // Buffer processing utilities
    std::vector<std::string> extractCompleteCommands(std::string& buffer);
    bool isCommandComplete(const std::string& buffer);
};

#endif

============================================================
FILE: includes/CommandHandlers.hpp
============================================================
#ifndef COMMANDHANDLERS_HPP
#define COMMANDHANDLERS_HPP

#include <string>
#include <vector>
#include "Client.hpp"
#include "Server.hpp"
#include "IRCProtocol.hpp"
#include <iostream>
#include <cstdlib>

class Server; // Forward declaration
class Client; // Forward declaration

class CommandHandlers {
private:
    Server* _server;

public:
    CommandHandlers(Server* server);
    ~CommandHandlers();

    // Authentication commands
    void handlePass(Client* client, const std::vector<std::string>& params);
    void handleNick(Client* client, const std::vector<std::string>& params);
    void handleUser(Client* client, const std::vector<std::string>& params);

    // Communication commands
    void handleJoin(Client* client, const std::vector<std::string>& params);
    void handlePart(Client* client, const std::vector<std::string>& params);
    void handlePrivmsg(Client* client, const std::vector<std::string>& params);
    void handleNotice(Client* client, const std::vector<std::string>& params);
    void handleQuit(Client* client, const std::vector<std::string>& params);

    // Channel operator commands
    void handleKick(Client* client, const std::vector<std::string>& params);
    void handleInvite(Client* client, const std::vector<std::string>& params);
    void handleTopic(Client* client, const std::vector<std::string>& params);
    void handleMode(Client* client, const std::vector<std::string>& params);

    // Utility functions
    void sendWelcomeSequence(Client* client);
    void sendErrorReply(Client* client, const std::string& code, const std::string& message);
    bool validateNickname(const std::string& nickname);
    bool validateChannelName(const std::string& channel);
};

#endif

============================================================
FILE: includes/IRCProtocol.hpp
============================================================
#ifndef IRCPROTOCOL_HPP
#define IRCPROTOCOL_HPP

#include <string>
#include <vector>

// IRC Numeric Reply Codes
namespace IRC {
    // Welcome messages
    const std::string RPL_WELCOME = "001";
    const std::string RPL_YOURHOST = "002";
    const std::string RPL_CREATED = "003";
    const std::string RPL_MYINFO = "004";
    
    // Channel operations
    const std::string RPL_NOTOPIC = "331";
    const std::string RPL_TOPIC = "332";
    const std::string RPL_NAMREPLY = "353";
    const std::string RPL_ENDOFNAMES = "366";
    
    // Error codes
    const std::string ERR_NOSUCHNICK = "401";
    const std::string ERR_NOSUCHCHANNEL = "403";
    const std::string ERR_CANNOTSENDTOCHAN = "404";
    const std::string ERR_TOOMANYCHANNELS = "405";
    const std::string ERR_UNKNOWNCOMMAND = "421";
    const std::string ERR_NONICKNAMEGIVEN = "431";
    const std::string ERR_ERRONEUSNICKNAME = "432";
    const std::string ERR_NICKNAMEINUSE = "433";
    const std::string ERR_USERNOTINCHANNEL = "441";
    const std::string ERR_NOTONCHANNEL = "442";
    const std::string ERR_USERONCHANNEL = "443";
    const std::string ERR_NOTREGISTERED = "451";
    const std::string ERR_NEEDMOREPARAMS = "461";
    const std::string ERR_ALREADYREGISTRED = "462";
    const std::string ERR_PASSWDMISMATCH = "464";
    const std::string ERR_CHANNELISFULL = "471";
    const std::string ERR_UNKNOWNMODE = "472";
    const std::string ERR_INVITEONLYCHAN = "473";
    const std::string ERR_BANNEDFROMCHAN = "474";
    const std::string ERR_BADCHANNELKEY = "475";
    const std::string ERR_CHANOPRIVSNEEDED = "482";
}

// IRC Command structure
struct IRCCommand {
    std::string prefix;
    std::string command;
    std::vector<std::string> params;
    std::string trailing;
};

// Protocol utility functions
std::string formatIRCMessage(const std::string& prefix, const std::string& command, 
                             const std::string& target, const std::string& message);
std::string formatNumericReply(const std::string& code, const std::string& target, 
                              const std::string& message);

#endif

============================================================
FILE: includes/Server.hpp
============================================================
#ifndef SERVER_HPP
#define SERVER_HPP

#include <map>
#include <string>
#include <vector>
#include <set>
#include "Client.hpp"
#include "Channel.hpp"

class Server {
private:
    std::map<int, Client*> _clients;                     // socket fd → Client
    std::map<std::string, Channel*> _channels;           // channel name → Channel
    std::string _password;                               // server password

public:
    Server();
    Server(const std::string& password);
    ~Server();

    // Configuration
    void setPassword(const std::string& password);
    const std::string& getPassword() const;

    // Client management
    void addClient(int fd);
    void removeClient(int fd);
    Client* getClient(int fd);
    Client* findClientByNick(const std::string& nickname);
    bool isNicknameInUse(const std::string& nickname);

    // Channel management
    Channel* getChannel(const std::string& name);
    Channel* createChannel(const std::string& name);
    void removeClientFromAllChannels(Client* client);
    void deleteChannelIfEmpty(Channel* channel);

    // Messaging - Enhanced for I/O layer
    void queueMessage(int clientFd, const std::string& message);
        
    // Channel utilities
    std::vector<Channel*> getClientChannels(Client* client);
    void sendMessage(int clientFd, const std::string& message);
    void broadcast(const std::set<int>& targets, const std::string& message);

    // I/O Interface methods
    void flushClientMessages(int clientFd);
    bool hasClientMessagesToSend(int clientFd) const;

    // Timeout handling
    void disconnectIdleClients(int timeoutSeconds);
};

#endif


============================================================
FILE: includes/utils.hpp
============================================================
#ifndef UTILS_HPP
#define UTILS_HPP

#include <string>
#include <vector>

// IRC message parsing utilities
namespace IRCUtils {
    // Extract complete IRC lines from a buffer
    std::vector<std::string> extractLines(std::string& buffer);

    // Parse IRC command line into components
    struct IRCMessage {
        std::string prefix;
        std::string command;
        std::vector<std::string> params;
    };

    IRCMessage parseIRCMessage(const std::string& line);

    // IRC reply formatting
    std::string formatReply(int code, const std::string& target, const std::string& message);

    // Common IRC numeric replies
    const int RPL_WELCOME = 001;
    const int RPL_YOURHOST = 002;
    const int RPL_CREATED = 003;
    const int RPL_MYINFO = 004;
    const int ERR_NONICKNAMEGIVEN = 431;
    const int ERR_ERRONEUSNICKNAME = 432;
    const int ERR_NICKNAMEINUSE = 433;
    const int ERR_NEEDMOREPARAMS = 461;
    const int ERR_ALREADYREGISTRED = 462;
    const int ERR_PASSWDMISMATCH = 464;
}

#endif


============================================================
FILE: srcs/Channel.cpp
============================================================
#include "Channel.hpp"
#include "Client.hpp"

Channel::Channel(const std::string& name)
    : _name(name), _topic(""), _inviteOnly(false), _topicRestricted(true), _key(""), _userLimit(0) {}

Channel::~Channel() {}

// Basic info
const std::string& Channel::getName() const {
    return _name;
}

const std::string& Channel::getTopic() const {
    return _topic;
}

void Channel::setTopic(const std::string& topic) {
    _topic = topic;
}

// Membership
void Channel::addClient(Client* client) {
    _members.insert(client);
}

void Channel::removeClient(Client* client) {
    _members.erase(client);
    _operators.erase(client); // Remove operator role if leaving
    _invitedClients.erase(client); // Remove from invite list when leaving
}

bool Channel::hasClient(Client* client) const {
    return _members.find(client) != _members.end();
}

const std::set<Client*>& Channel::getMembers() const {
    return _members;
}


// Operators
void Channel::addOperator(Client* client) {
    _operators.insert(client);
}

void Channel::removeOperator(Client* client) {
    _operators.erase(client);
}

bool Channel::isOperator(Client* client) const {
    return _operators.find(client) != _operators.end();
}

// Messaging
void Channel::broadcast(const std::string& message, Client* sender) {
    for (std::set<Client*>::iterator it = _members.begin(); it != _members.end(); ++it) {
        if (*it != sender) {
            (*it)->getOutputBuffer() += message + "\r\n";
        }
    }
}

// Mode methods
bool Channel::isInviteOnly() const {
    return _inviteOnly;
}

bool Channel::isTopicRestricted() const {
    return _topicRestricted;
}

const std::string& Channel::getKey() const {
    return _key;
}

size_t Channel::getUserLimit() const {
    return _userLimit;
}

void Channel::setInviteOnly(bool inviteOnly) {
    _inviteOnly = inviteOnly;
}

void Channel::setTopicRestricted(bool topicRestricted) {
    _topicRestricted = topicRestricted;
}

void Channel::setKey(const std::string& key) {
    _key = key;
}

void Channel::setUserLimit(size_t limit) {
    _userLimit = limit;
}

std::string Channel::getModeString() const {
    std::string modes = "+";
    
    if (_inviteOnly) modes += "i";
    if (_topicRestricted) modes += "t";
    if (!_key.empty()) modes += "k";
    if (_userLimit > 0) modes += "l";
    
    if (modes == "+") modes = "";
    
    return modes;
}

// Invite management
void Channel::addInvite(Client* client) {
    _invitedClients.insert(client);
}

void Channel::removeInvite(Client* client) {
    _invitedClients.erase(client);
}

bool Channel::isInvited(Client* client) const {
    return _invitedClients.find(client) != _invitedClients.end();
}


============================================================
FILE: srcs/Client.cpp
============================================================
#include "Client.hpp"
#include <ctime>

Client::Client(int fd)
    : _fd(fd),
      _receivedPass(false),
      _receivedNick(false),
      _receivedUser(false),
      _registered(false),
      _lastActive(time(NULL)) {}

Client::~Client() {}

// Getters
int Client::getFd() const { return _fd; }

const std::string& Client::getNickname() const { return _nickname; }

const std::string& Client::getUsername() const { return _username; }

const std::string& Client::getRealname() const { return _realname; }

const std::string& Client::getHostname() const { return _hostname; }

std::string Client::getHostmask() const {
    return _nickname + "!" + _username + "@" + _hostname;
}

bool Client::isRegistered() const { return _registered; }

time_t Client::getLastActive() const { return _lastActive; }

// Setters
void Client::setNickname(const std::string& nick) {
    _nickname = nick;
    _receivedNick = true;
    tryRegister();
}

void Client::setUsername(const std::string& user) {
    _username = user;
    _receivedUser = true;
    tryRegister();
}

void Client::setRealname(const std::string& realname) {
    _realname = realname;
}

void Client::setHostname(const std::string& hostname) {
    _hostname = hostname;
}

void Client::setReceivedPass(bool received) {
    _receivedPass = received;
    tryRegister();
}

void Client::setReceivedNick(bool received) {
    _receivedNick = received;
    tryRegister();
}

void Client::setReceivedUser(bool received) {
    _receivedUser = received;
    tryRegister();
}

void Client::updateLastActive() {
    _lastActive = time(NULL);
}

// Auto-register when all fields are filled
void Client::tryRegister() {
    if (_receivedPass && _receivedNick && _receivedUser && !_registered) {
        _registered = true;
    }
}

// Buffer handling
void Client::appendToInputBuffer(const std::string& data) {
    _inputBuffer += data;
    updateLastActive();
}

std::string& Client::getInputBuffer() {
    return _inputBuffer;
}

std::string& Client::getOutputBuffer() {
    return _outputBuffer;
}

// Message queue handling
void Client::enqueueMessage(const std::string& message) {
    _outBufQ.push_back(message);
}

bool Client::hasMessagesToSend() const {
    return !_outBufQ.empty() || !_outputBuffer.empty();
}

void Client::flushMessagesToOutputBuffer() {
    while (!_outBufQ.empty() && _outputBuffer.empty()) {
        _outputBuffer = _outBufQ.front() + "\r\n";
        _outBufQ.pop_front();
    }
}

// Line extraction for IRC command parsing
std::string Client::extractNextLine() {
    size_t pos = _inputBuffer.find("\r\n");
    if (pos == std::string::npos) {
        return "";
    }

    std::string line = _inputBuffer.substr(0, pos);
    _inputBuffer.erase(0, pos + 2);
    return line;
}

bool Client::hasCompleteLine() const {
    return _inputBuffer.find("\r\n") != std::string::npos;
}


============================================================
FILE: srcs/Command.cpp
============================================================
#include "Command.hpp"
#include <iostream>
#include <sstream>
#include <algorithm>
#include "CommandHandlers.hpp"


Command::Command(Server* server) : _server(server) {
    _handlers = new CommandHandlers(server);
    initializeCommandMap();
}

Command::~Command() {
    delete _handlers;
}

void Command::initializeCommandMap() {
    _commandMap["PASS"] = &CommandHandlers::handlePass;
    _commandMap["NICK"] = &CommandHandlers::handleNick;
    _commandMap["USER"] = &CommandHandlers::handleUser;
    _commandMap["JOIN"] = &CommandHandlers::handleJoin;
    _commandMap["PART"] = &CommandHandlers::handlePart;
    _commandMap["PRIVMSG"] = &CommandHandlers::handlePrivmsg;
    _commandMap["NOTICE"] = &CommandHandlers::handleNotice;
    _commandMap["QUIT"] = &CommandHandlers::handleQuit;
    _commandMap["KICK"] = &CommandHandlers::handleKick;
    _commandMap["INVITE"] = &CommandHandlers::handleInvite;
    _commandMap["TOPIC"] = &CommandHandlers::handleTopic;
    _commandMap["MODE"] = &CommandHandlers::handleMode;
}

void Command::processClientBuffer(Client* client) {
    std::string& buffer = client->getInputBuffer();
    
    // Extract complete commands from buffer
    std::vector<std::string> commands = extractCompleteCommands(buffer);
    
    // Process each complete command
    for (std::vector<std::string>::iterator it = commands.begin(); it != commands.end(); ++it) {
        IRCCommand cmd = parseRawCommand(*it);
        executeCommand(client, cmd);
    }
}

std::vector<std::string> Command::extractCompleteCommands(std::string& buffer) {
    std::vector<std::string> commands;
    size_t pos = 0;
    
    while ((pos = buffer.find("\r\n")) != std::string::npos) {
        std::string command = buffer.substr(0, pos);
        commands.push_back(command);
        buffer.erase(0, pos + 2); // Remove command + \r\n
    }
    
    return commands;
}

//unused search why we put it if we don't use it (hicham)
bool Command::isCommandComplete(const std::string& buffer) {
    return buffer.find("\r\n") != std::string::npos;
}

IRCCommand Command::parseRawCommand(const std::string& rawCommand) {
    IRCCommand cmd;
    std::string line = rawCommand;
    
    // Remove trailing whitespace
    while (!line.empty() && (line[line.size() - 1] == ' ' || line[line.size() - 1] == '\t')) {
    line.erase(line.size() - 1);
    }
    
    // Handle empty commands
    if (line.empty()) {
        return cmd; // Return empty command (will be ignored)
    }
    
    size_t pos = 0;
    
    // Parse prefix (if exists)
    if (!line.empty() && line[0] == ':') {
        pos = line.find(' ');
        if (pos != std::string::npos) {
            cmd.prefix = line.substr(1, pos - 1);
            line = line.substr(pos + 1);
        }
    }
    
    // Parse command
    pos = line.find(' ');
    if (pos != std::string::npos) {
        cmd.command = line.substr(0, pos);
        line = line.substr(pos + 1);
        
        // Parse parameters
        pos = line.find(" :");
        if (pos != std::string::npos) {
            // Has trailing parameter
            std::string params = line.substr(0, pos);
            cmd.trailing = line.substr(pos + 2);
            cmd.params = splitParams(params);
        } else {
            // No trailing parameter
            cmd.params = splitParams(line);
        }
    } else {
        // Command with no parameters
        cmd.command = line;
    }
    
    // Convert command to uppercase for consistency
    std::transform(cmd.command.begin(), cmd.command.end(), cmd.command.begin(), ::toupper);
    
    return cmd;
}

std::vector<std::string> Command::splitParams(const std::string& params) {
    std::vector<std::string> result;
    std::istringstream iss(params);
    std::string param;
    
    while (iss >> param) {
        result.push_back(param);
    }
    
    return result;
}

void Command::executeCommand(Client* client, const IRCCommand& cmd) {
    // Ignore empty commands
    if (cmd.command.empty()) {
        return;
    }
    
    // Find command handler
    std::map<std::string, void (CommandHandlers::*)(Client*, const std::vector<std::string>&)>::iterator it;
    it = _commandMap.find(cmd.command);
    
    if (it != _commandMap.end()) {
        // Prepare parameters (include trailing if exists)
        std::vector<std::string> allParams = cmd.params;
        if (!cmd.trailing.empty()) {
            allParams.push_back(cmd.trailing);
        }
        
        // Call the appropriate handler
        ((_handlers)->*(it->second))(client, allParams);
    } else {
        // Unknown command
        _handlers->sendErrorReply(client, IRC::ERR_UNKNOWNCOMMAND, cmd.command + " :Unknown command");
    }
}

============================================================
FILE: srcs/CommandHandlers.cpp
============================================================
#include "CommandHandlers.hpp"
#include "Server.hpp"
#include "Channel.hpp"


CommandHandlers::CommandHandlers(Server* server) : _server(server) {}

CommandHandlers::~CommandHandlers() {}

// Authentication commands
void CommandHandlers::handlePass(Client* client, const std::vector<std::string>& params) {
    if (params.empty()) {
        sendErrorReply(client, IRC::ERR_NEEDMOREPARAMS, "PASS :Not enough parameters");
        return;
    }
    
    if (client->isRegistered()) {
        sendErrorReply(client, IRC::ERR_ALREADYREGISTRED, "You may not reregister");
        return;
    }
    
    const std::string& password = params[0];
    if (password != _server->getPassword()) {
        sendErrorReply(client, IRC::ERR_PASSWDMISMATCH, "Password incorrect");
        return;
    }
    
    client->setReceivedPass(true);
    client->tryRegister();
}

void CommandHandlers::handleNick(Client* client, const std::vector<std::string>& params) {
    if (params.empty()) {
        sendErrorReply(client, IRC::ERR_NONICKNAMEGIVEN, "No nickname given");
        return;
    }
    
    const std::string& nickname = params[0];
    
    if (!validateNickname(nickname)) {
        sendErrorReply(client, IRC::ERR_ERRONEUSNICKNAME, nickname + " :Erroneous nickname");
        return;
    }
    
    if (_server->isNicknameInUse(nickname)) {
        sendErrorReply(client, IRC::ERR_NICKNAMEINUSE, nickname + " :Nickname is already in use");
        return;
    }
    
    client->setNickname(nickname);
    client->setReceivedNick(true);
    client->tryRegister();
}

void CommandHandlers::handleUser(Client* client, const std::vector<std::string>& params) {
    if (params.size() < 4) {
        sendErrorReply(client, IRC::ERR_NEEDMOREPARAMS, "USER :Not enough parameters");
        return;
    }
    
    client->setUsername(params[0]);
    client->setRealname(params[3]);
    client->setReceivedUser(true);
    client->tryRegister();
    
    if (client->isRegistered()) {
        sendWelcomeSequence(client);
    }
}

// Communication commands
void CommandHandlers::handleJoin(Client* client, const std::vector<std::string>& params) {
    if (!client->isRegistered()) {
        sendErrorReply(client, IRC::ERR_NOTREGISTERED, "You have not registered");
        return;
    }
    
    if (params.empty()) {
        sendErrorReply(client, IRC::ERR_NEEDMOREPARAMS, "JOIN :Not enough parameters");
        return;
    }
    
    const std::string& channelName = params[0];
    std::string channelKey = (params.size() > 1) ? params[1] : "";
    
    if (!validateChannelName(channelName)) {
        sendErrorReply(client, IRC::ERR_NOSUCHCHANNEL, channelName + " :No such channel");
        return;
    }
    
    Channel* channel = _server->getChannel(channelName);
    if (!channel) {
        channel = _server->createChannel(channelName);
        // Make the first client an operator
        channel->addOperator(client);
    } else {
        // Check channel restrictions
        if (channel->isInviteOnly() && !channel->isInvited(client)) {
            sendErrorReply(client, IRC::ERR_INVITEONLYCHAN, channelName + " :Cannot join channel (+i)");
            return;
        }
        
        if (channel->getUserLimit() > 0 && channel->getMembers().size() >= channel->getUserLimit()) {
            sendErrorReply(client, IRC::ERR_CHANNELISFULL, channelName + " :Cannot join channel (+l)");
            return;
        }
        
        if (!channel->getKey().empty()) {
            if (channelKey != channel->getKey()) {
                sendErrorReply(client, IRC::ERR_BADCHANNELKEY, channelName + " :Cannot join channel (+k)");
                return;
            }
        }
    }
    
    channel->addClient(client);
    
    // Remove from invite list once joined (invite consumed)
    if (channel->isInvited(client)) {
        channel->removeInvite(client);
    }
    
    // Send JOIN confirmation and channel info
    std::string joinMsg = formatIRCMessage(client->getHostmask(), "JOIN", channelName, "");
    channel->broadcast(joinMsg, NULL); // Broadcast to all including sender
    
    // Send topic information to the joining client
    const std::string& topic = channel->getTopic();
    if (topic.empty()) {
        std::string noTopicReply = formatNumericReply(IRC::RPL_NOTOPIC, client->getNickname(), channelName + " :No topic is set");
        _server->queueMessage(client->getFd(), noTopicReply);
    } else {
        std::string topicReply = formatNumericReply(IRC::RPL_TOPIC, client->getNickname(), channelName + " :" + topic);
        _server->queueMessage(client->getFd(), topicReply);
    }
    
    // Send NAMES list to the joining client
    std::string nameList = "= " + channelName + " :";
    const std::set<Client*>& members = channel->getMembers();
    for (std::set<Client*>::const_iterator it = members.begin(); it != members.end(); ++it) {
        if (channel->isOperator(*it)) {
            nameList += "@" + (*it)->getNickname() + " ";
        } else {
            nameList += (*it)->getNickname() + " ";
        }
    }
    _server->queueMessage(client->getFd(), formatNumericReply(IRC::RPL_NAMREPLY, client->getNickname(), nameList));
    _server->queueMessage(client->getFd(), formatNumericReply(IRC::RPL_ENDOFNAMES, client->getNickname(), channelName + " :End of /NAMES list"));
}

void CommandHandlers::handlePrivmsg(Client* client, const std::vector<std::string>& params) {
    if (!client->isRegistered()) {
        sendErrorReply(client, IRC::ERR_NOTREGISTERED, "You have not registered");
        return;
    }
    
    if (params.size() < 2) {
        sendErrorReply(client, IRC::ERR_NEEDMOREPARAMS, "PRIVMSG :Not enough parameters");
        return;
    }
    
    const std::string& target = params[0];
    const std::string& message = params[1];
    
    if (target[0] == '#') {
        // Channel message
        Channel* channel = _server->getChannel(target);
        if (!channel) {
            sendErrorReply(client, IRC::ERR_NOSUCHCHANNEL, target + " :No such channel");
            return;
        }
        
        if (!channel->hasClient(client)) {
            sendErrorReply(client, IRC::ERR_NOTONCHANNEL, target + " :You're not on that channel");
            return;
        }
        
        std::string privmsg = formatIRCMessage(client->getHostmask(), "PRIVMSG", target, message);
        channel->broadcast(privmsg, client); // Don't send back to sender
    } else {
        // Private message to user
        Client* targetClient = _server->findClientByNick(target);
        if (!targetClient) {
            sendErrorReply(client, IRC::ERR_NOSUCHNICK, target + " :No such nick/channel");
            return;
        }
        
        std::string privmsg = formatIRCMessage(client->getHostmask(), "PRIVMSG", target, message);
        _server->queueMessage(targetClient->getFd(), privmsg);
    }
}

void CommandHandlers::handleNotice(Client* client, const std::vector<std::string>& params) {
    if (!client->isRegistered()) {
        // NOTICE doesn't send error replies - this is intentional per IRC spec
        return;
    }
    
    if (params.size() < 2) {
        // NOTICE doesn't send error replies - this is intentional per IRC spec
        return;
    }
    
    const std::string& target = params[0];
    const std::string& message = params[1];
    
    if (target[0] == '#') {
        // Channel notice
        Channel* channel = _server->getChannel(target);
        if (!channel) {
            // NOTICE doesn't send error replies - silently ignore
            return;
        }
        
        if (!channel->hasClient(client)) {
            // NOTICE doesn't send error replies - silently ignore
            return;
        }
        
        std::string noticeMsg = formatIRCMessage(client->getHostmask(), "NOTICE", target, message);
        channel->broadcast(noticeMsg, client); // Don't send back to sender
    } else {
        // Private notice to user
        Client* targetClient = _server->findClientByNick(target);
        if (!targetClient) {
            // NOTICE doesn't send error replies - silently ignore
            return;
        }
        
        std::string noticeMsg = formatIRCMessage(client->getHostmask(), "NOTICE", target, message);
        _server->queueMessage(targetClient->getFd(), noticeMsg);
    }
}

// Placeholder implementations for other commands
void CommandHandlers::handlePart(Client* client, const std::vector<std::string>& params) {
    if (!client->isRegistered()) {
        sendErrorReply(client, IRC::ERR_NOTREGISTERED, "You have not registered");
        return;
    }
    
    if (params.empty()) {
        sendErrorReply(client, IRC::ERR_NEEDMOREPARAMS, "PART :Not enough parameters");
        return;
    }
    
    const std::string& channelName = params[0];
    std::string partMessage = (params.size() > 1) ? params[1] : "";
    
    if (!validateChannelName(channelName)) {
        sendErrorReply(client, IRC::ERR_NOSUCHCHANNEL, channelName + " :No such channel");
        return;
    }
    
    Channel* channel = _server->getChannel(channelName);
    if (!channel) {
        sendErrorReply(client, IRC::ERR_NOSUCHCHANNEL, channelName + " :No such channel");
        return;
    }
    
    if (!channel->hasClient(client)) {
        sendErrorReply(client, IRC::ERR_NOTONCHANNEL, channelName + " :You're not on that channel");
        return;
    }
    
    // Send PART message to all channel members (including sender)
    std::string partMsg = formatIRCMessage(client->getHostmask(), "PART", channelName, partMessage);
    channel->broadcast(partMsg, NULL); // Send to all including sender
    
    // Remove client from channel
    channel->removeClient(client);
    
    // Delete channel if empty
    _server->deleteChannelIfEmpty(channel);
}

void CommandHandlers::handleQuit(Client* client, const std::vector<std::string>& params) {
    std::string quitMessage = (params.empty()) ? "Client Quit" : params[0];
    
    // Send QUIT message to all channels the client is in before removing them
    std::string quitMsg = formatIRCMessage(client->getHostmask(), "QUIT", "", quitMessage);
    
    // Get all channels this client is in
    std::vector<Channel*> channelsWithClient = _server->getClientChannels(client);
    
    // Broadcast QUIT to all channels (excluding the quitting client)
    for (std::vector<Channel*>::iterator it = channelsWithClient.begin(); 
         it != channelsWithClient.end(); ++it) {
        (*it)->broadcast(quitMsg, client); // Don't send to the quitting client
    }
    
    // Remove client from all channels
    _server->removeClientFromAllChannels(client);
    
    // Note: The actual client disconnection (closing socket, removing from server)
    // should be handled by the I/O layer, not here. We just handle the IRC protocol part.
}

void CommandHandlers::handleKick(Client* client, const std::vector<std::string>& params) {
    if (!client->isRegistered()) {
        sendErrorReply(client, IRC::ERR_NOTREGISTERED, "You have not registered");
        return;
    }
    
    if (params.size() < 2) {
        sendErrorReply(client, IRC::ERR_NEEDMOREPARAMS, "KICK :Not enough parameters");
        return;
    }
    
    const std::string& channelName = params[0];
    const std::string& targetNick = params[1];
    std::string kickReason = (params.size() > 2) ? params[2] : client->getNickname();
    
    // Validate channel name
    if (!validateChannelName(channelName)) {
        sendErrorReply(client, IRC::ERR_NOSUCHCHANNEL, channelName + " :No such channel");
        return;
    }
    
    // Get channel
    Channel* channel = _server->getChannel(channelName);
    if (!channel) {
        sendErrorReply(client, IRC::ERR_NOSUCHCHANNEL, channelName + " :No such channel");
        return;
    }
    
    // Check if client is on the channel
    if (!channel->hasClient(client)) {
        sendErrorReply(client, IRC::ERR_NOTONCHANNEL, channelName + " :You're not on that channel");
        return;
    }
    
    // Check if client is operator
    if (!channel->isOperator(client)) {
        sendErrorReply(client, IRC::ERR_CHANOPRIVSNEEDED, channelName + " :You're not channel operator");
        return;
    }
    
    // Find target client
    Client* targetClient = _server->findClientByNick(targetNick);
    if (!targetClient) {
        sendErrorReply(client, IRC::ERR_NOSUCHNICK, targetNick + " :No such nick/channel");
        return;
    }
    
    // Check if target is on the channel
    if (!channel->hasClient(targetClient)) {
        sendErrorReply(client, IRC::ERR_USERNOTINCHANNEL, targetNick + " " + channelName + " :They aren't on that channel");
        return;
    }
    
    // Send KICK message to all channel members (including target and kicker)
    std::string kickMsg = formatIRCMessage(client->getHostmask(), "KICK", channelName + " " + targetNick, kickReason);
    channel->broadcast(kickMsg, NULL); // Send to all including sender
    
    // Remove target from channel
    channel->removeClient(targetClient);
    
    // Delete channel if empty
    _server->deleteChannelIfEmpty(channel);
}

void CommandHandlers::handleInvite(Client* client, const std::vector<std::string>& params) {
    if (!client->isRegistered()) {
        sendErrorReply(client, IRC::ERR_NOTREGISTERED, "You have not registered");
        return;
    }
    
    if (params.size() < 2) {
        sendErrorReply(client, IRC::ERR_NEEDMOREPARAMS, "INVITE :Not enough parameters");
        return;
    }
    
    const std::string& targetNick = params[0];
    const std::string& channelName = params[1];
    
    // Validate channel name
    if (!validateChannelName(channelName)) {
        sendErrorReply(client, IRC::ERR_NOSUCHCHANNEL, channelName + " :No such channel");
        return;
    }
    
    // Find target client
    Client* targetClient = _server->findClientByNick(targetNick);
    if (!targetClient) {
        sendErrorReply(client, IRC::ERR_NOSUCHNICK, targetNick + " :No such nick/channel");
        return;
    }
    
    // Get channel
    Channel* channel = _server->getChannel(channelName);
    if (!channel) {
        sendErrorReply(client, IRC::ERR_NOSUCHCHANNEL, channelName + " :No such channel");
        return;
    }
    
    // Check if client is on the channel
    if (!channel->hasClient(client)) {
        sendErrorReply(client, IRC::ERR_NOTONCHANNEL, channelName + " :You're not on that channel");
        return;
    }
    
    // Check if client is operator (required for INVITE)
    if (!channel->isOperator(client)) {
        sendErrorReply(client, IRC::ERR_CHANOPRIVSNEEDED, channelName + " :You're not channel operator");
        return;
    }
    
    // Check if target is already on the channel
    if (channel->hasClient(targetClient)) {
        sendErrorReply(client, IRC::ERR_USERONCHANNEL, targetNick + " " + channelName + " :is already on channel");
        return;
    }
    
    // Add target to invite list
    channel->addInvite(targetClient);
    
    // Send INVITE confirmation to inviter
    std::string inviteReply = formatNumericReply("341", client->getNickname(), targetNick + " " + channelName);
    _server->queueMessage(client->getFd(), inviteReply);
    
    // Send INVITE notification to target
    std::string inviteMsg = formatIRCMessage(client->getHostmask(), "INVITE", targetNick, channelName);
    _server->queueMessage(targetClient->getFd(), inviteMsg);
}

void CommandHandlers::handleTopic(Client* client, const std::vector<std::string>& params) {
    if (!client->isRegistered()) {
        sendErrorReply(client, IRC::ERR_NOTREGISTERED, "You have not registered");
        return;
    }
    
    if (params.empty()) {
        sendErrorReply(client, IRC::ERR_NEEDMOREPARAMS, "TOPIC :Not enough parameters");
        return;
    }
    
    const std::string& channelName = params[0];
    
    // Validate channel name
    if (!validateChannelName(channelName)) {
        sendErrorReply(client, IRC::ERR_NOSUCHCHANNEL, channelName + " :No such channel");
        return;
    }
    
    // Get channel
    Channel* channel = _server->getChannel(channelName);
    if (!channel) {
        sendErrorReply(client, IRC::ERR_NOSUCHCHANNEL, channelName + " :No such channel");
        return;
    }
    
    // Check if client is on the channel
    if (!channel->hasClient(client)) {
        sendErrorReply(client, IRC::ERR_NOTONCHANNEL, channelName + " :You're not on that channel");
        return;
    }
    
    if (params.size() == 1) {
        // View topic
        const std::string& topic = channel->getTopic();
        if (topic.empty()) {
            std::string noTopicReply = formatNumericReply(IRC::RPL_NOTOPIC, client->getNickname(), channelName + " :No topic is set");
            _server->queueMessage(client->getFd(), noTopicReply);
        } else {
            std::string topicReply = formatNumericReply(IRC::RPL_TOPIC, client->getNickname(), channelName + " :" + topic);
            _server->queueMessage(client->getFd(), topicReply);
        }
    } else {
        // Set topic - check if client has permission
        if (channel->isTopicRestricted() && !channel->isOperator(client)) {
            sendErrorReply(client, IRC::ERR_CHANOPRIVSNEEDED, channelName + " :You're not channel operator");
            return;
        }
        
        const std::string& newTopic = params[1];
        channel->setTopic(newTopic);
        
        // Broadcast topic change to all channel members
        std::string topicMsg = formatIRCMessage(client->getHostmask(), "TOPIC", channelName, newTopic);
        channel->broadcast(topicMsg, NULL); // Send to all including sender
    }
}

void CommandHandlers::handleMode(Client* client, const std::vector<std::string>& params) {
    if (!client->isRegistered()) {
        sendErrorReply(client, IRC::ERR_NOTREGISTERED, "You have not registered");
        return;
    }
    
    if (params.empty()) {
        sendErrorReply(client, IRC::ERR_NEEDMOREPARAMS, "MODE :Not enough parameters");
        return;
    }
    
    const std::string& target = params[0];
    
    // Only handle channel modes (target starts with #)
    if (target[0] != '#') {
        sendErrorReply(client, IRC::ERR_UNKNOWNMODE, "User modes not supported");
        return;
    }
    
    // Validate channel name
    if (!validateChannelName(target)) {
        sendErrorReply(client, IRC::ERR_NOSUCHCHANNEL, target + " :No such channel");
        return;
    }
    
    // Get channel
    Channel* channel = _server->getChannel(target);
    if (!channel) {
        sendErrorReply(client, IRC::ERR_NOSUCHCHANNEL, target + " :No such channel");
        return;
    }
    
    // Check if client is on the channel
    if (!channel->hasClient(client)) {
        sendErrorReply(client, IRC::ERR_NOTONCHANNEL, target + " :You're not on that channel");
        return;
    }
    
    if (params.size() == 1) {
        // Query mode - return current channel modes
        std::string modeString = channel->getModeString();
        if (modeString.empty()) modeString = "+";
        
        std::string modeReply = formatNumericReply("324", client->getNickname(), target + " " + modeString);
        _server->queueMessage(client->getFd(), modeReply);
        return;
    }
    
    // Setting modes - check if client is operator
    if (!channel->isOperator(client)) {
        sendErrorReply(client, IRC::ERR_CHANOPRIVSNEEDED, target + " :You're not channel operator");
        return;
    }
    
    const std::string& modeString = params[1];
    std::vector<std::string> modeParams;
    for (size_t i = 2; i < params.size(); ++i) {
        modeParams.push_back(params[i]);
    }
    
    // Parse and apply modes
    bool adding = true;
    size_t paramIndex = 0;
    std::string appliedAdd = "";
    std::string appliedRemove = "";
    std::string appliedParams = "";
    
    for (size_t i = 0; i < modeString.length(); ++i) {
        char mode = modeString[i];
        
        if (mode == '+') {
            adding = true;
            continue;
        }
        if (mode == '-') {
            adding = false;
            continue;
        }
        
        switch (mode) {
            case 'i': // Invite only
                channel->setInviteOnly(adding);
                if (adding) appliedAdd += "i";
                else appliedRemove += "i";
                break;
                
            case 't': // Topic restricted
                channel->setTopicRestricted(adding);
                if (adding) appliedAdd += "t";
                else appliedRemove += "t";
                break;
                
            case 'k': // Channel key (password)
                if (adding && paramIndex < modeParams.size()) {
                    channel->setKey(modeParams[paramIndex]);
                    appliedAdd += "k";
                    appliedParams += " " + modeParams[paramIndex];
                    paramIndex++;
                } else if (!adding) {
                    channel->setKey("");
                    appliedRemove += "k";
                }
                break;
                
            case 'l': // User limit
                if (adding && paramIndex < modeParams.size()) {
                    int limitInt = std::atoi(modeParams[paramIndex].c_str());
                    if (limitInt > 0) {
                        size_t limit = static_cast<size_t>(limitInt);
                        channel->setUserLimit(limit);
                        appliedAdd += "l";
                        appliedParams += " " + modeParams[paramIndex];
                    }
                    paramIndex++;
                } else if (!adding) {
                    channel->setUserLimit(0);
                    appliedRemove += "l";
                }
                break;
                
            case 'o': // Operator privilege
                if (paramIndex < modeParams.size()) {
                    Client* targetClient = _server->findClientByNick(modeParams[paramIndex]);
                    if (targetClient && channel->hasClient(targetClient)) {
                        if (adding) {
                            channel->addOperator(targetClient);
                            appliedAdd += "o";
                        } else {
                            channel->removeOperator(targetClient);
                            appliedRemove += "o";
                        }
                        appliedParams += " " + modeParams[paramIndex];
                    }
                    paramIndex++;
                }
                break;
                
            default:
                sendErrorReply(client, IRC::ERR_UNKNOWNMODE, std::string(1, mode) + " :is unknown mode char to me");
                return;
        }
    }
    
    // Broadcast mode change to all channel members
    std::string finalModes = "";
    if (!appliedAdd.empty()) {
        finalModes += "+" + appliedAdd;
    }
    if (!appliedRemove.empty()) {
        finalModes += "-" + appliedRemove;
    }
    
    if (!finalModes.empty()) {
        std::string modeMsg = formatIRCMessage(client->getHostmask(), "MODE", target + " " + finalModes + appliedParams, "");
        channel->broadcast(modeMsg, NULL); // Send to all including sender
    }
}

// Utility functions
void CommandHandlers::sendWelcomeSequence(Client* client) {
    std::string nick = client->getNickname();
    _server->queueMessage(client->getFd(), formatNumericReply(IRC::RPL_WELCOME, nick, "Welcome to the IRC Network " + client->getHostmask()));
    _server->queueMessage(client->getFd(), formatNumericReply(IRC::RPL_YOURHOST, nick, "Your host is localhost, running version 1.0"));
    _server->queueMessage(client->getFd(), formatNumericReply(IRC::RPL_CREATED, nick, "This server was created today"));
    _server->queueMessage(client->getFd(), formatNumericReply(IRC::RPL_MYINFO, nick, "localhost 1.0 o o"));
}

void CommandHandlers::sendErrorReply(Client* client, const std::string& code, const std::string& message) {
    std::string nick = client->getNickname().empty() ? "*" : client->getNickname();
    _server->queueMessage(client->getFd(), formatNumericReply(code, nick, message));
}

bool CommandHandlers::validateNickname(const std::string& nickname) {
    if (nickname.empty() || nickname.length() > 9) {
        return false;
    }
    
    // First character must be letter or special char
    char first = nickname[0];
    if (!std::isalpha(first) && first != '[' && first != ']' && first != '\\' && 
        first != '`' && first != '_' && first != '^' && first != '{' && first != '}') {
        return false;
    }
    
    // Rest can be alphanumeric or special chars
    for (size_t i = 1; i < nickname.length(); ++i) {
        char c = nickname[i];
        if (!std::isalnum(c) && c != '[' && c != ']' && c != '\\' && 
            c != '`' && c != '_' && c != '^' && c != '{' && c != '}' && c != '-') {
            return false;
        }
    }
    
    return true;
}

bool CommandHandlers::validateChannelName(const std::string& channel) {
    if (channel.empty() || channel[0] != '#' || channel.length() > 50) {
        return false;
    }
    
    // Channel names cannot contain spaces, commas, or control characters
    for (size_t i = 1; i < channel.length(); ++i) {
        char c = channel[i];
        if (c == ' ' || c == ',' || c == '\r' || c == '\n' || c == '\0') {
            return false;
        }
    }
    
    return true;
}

============================================================
FILE: srcs/IRCProtocol.cpp
============================================================
#include "IRCProtocol.hpp"
#include <sstream>

std::string formatIRCMessage(const std::string& prefix, const std::string& command, 
                             const std::string& target, const std::string& message) {
    std::ostringstream oss;
    
    if (!prefix.empty()) {
        oss << ":" << prefix << " ";
    }
    
    oss << command;
    
    if (!target.empty()) {
        oss << " " << target;
    }
    
    if (!message.empty()) {
        oss << " :" << message;
    }
    
    oss << "\r\n";
    return oss.str();
}

std::string formatNumericReply(const std::string& code, const std::string& target, 
                              const std::string& message) {
    std::ostringstream oss;
    oss << ":" << "localhost" << " " << code << " " << target << " :" << message << "\r\n";
    return oss.str();
}

============================================================
FILE: srcs/Server.cpp
============================================================
#include "Server.hpp"
#include <iostream>
#include <ctime>

// Constructor/Destructor
Server::Server() {}

Server::Server(const std::string& password) : _password(password) {}

Server::~Server() {
    for (std::map<int, Client*>::iterator it = _clients.begin(); it != _clients.end(); ++it)
        delete it->second;
    for (std::map<std::string, Channel*>::iterator it = _channels.begin(); it != _channels.end(); ++it)
        delete it->second;
}

// Configuration
void Server::setPassword(const std::string& password) {
    _password = password;
}

const std::string& Server::getPassword() const {
    return _password;
}

// -------- CLIENT METHODS --------

void Server::addClient(int fd) {
    if (_clients.find(fd) == _clients.end())
        _clients[fd] = new Client(fd);
}

void Server::removeClient(int fd) {
    std::map<int, Client*>::iterator it = _clients.find(fd);
    if (it != _clients.end()) {
        removeClientFromAllChannels(it->second);
        delete it->second;
        _clients.erase(it);
    }
}

Client* Server::getClient(int fd) {
    std::map<int, Client*>::iterator it = _clients.find(fd);
    return (it != _clients.end()) ? it->second : NULL;
}

Client* Server::findClientByNick(const std::string& nickname) {
    for (std::map<int, Client*>::iterator it = _clients.begin(); it != _clients.end(); ++it) {
        if (it->second->getNickname() == nickname)
            return it->second;
    }
    return NULL;
}

bool Server::isNicknameInUse(const std::string& nickname) {
    return findClientByNick(nickname) != NULL;
}

// -------- CHANNEL METHODS --------

Channel* Server::getChannel(const std::string& name) {
    std::map<std::string, Channel*>::iterator it = _channels.find(name);
    return (it != _channels.end()) ? it->second : NULL;
}

Channel* Server::createChannel(const std::string& name) {
    if (_channels.find(name) == _channels.end())
        _channels[name] = new Channel(name);
    return _channels[name];
}

void Server::removeClientFromAllChannels(Client* client) {
    std::vector<Channel*> channelsToCheck;

    // First, collect all channels that have this client
    for (std::map<std::string, Channel*>::iterator it = _channels.begin(); it != _channels.end(); ++it) {
        if (it->second->hasClient(client)) {
            channelsToCheck.push_back(it->second);
        }
    }

    // Then remove the client from each channel and check if empty
    for (std::vector<Channel*>::iterator it = channelsToCheck.begin(); it != channelsToCheck.end(); ++it) {
        (*it)->removeClient(client);
        deleteChannelIfEmpty(*it);
    }
}

void Server::deleteChannelIfEmpty(Channel* channel) {
    if (!channel)
        return;

    // Check if it's in the map
    std::map<std::string, Channel*>::iterator it = _channels.find(channel->getName());
    if (it == _channels.end())
        return;

    // If no members, delete and erase
    if (channel->getMembers().empty()) {
        delete channel;
        _channels.erase(it);
    }
}

// -------- MESSAGING --------

void Server::queueMessage(int clientFd, const std::string& message) {
    Client* client = getClient(clientFd);
    if (client)
        client->enqueueMessage(message);
}

void Server::sendMessage(int clientFd, const std::string& message) {
    queueMessage(clientFd, message);
}

void Server::broadcast(const std::set<int>& targets, const std::string& message) {
    for (std::set<int>::const_iterator it = targets.begin(); it != targets.end(); ++it) {
        queueMessage(*it, message);
    }
}

// -------- I/O INTERFACE METHODS --------

void Server::flushClientMessages(int clientFd) {
    Client* client = getClient(clientFd);
    if (client) {
        client->flushMessagesToOutputBuffer();
    }
}

bool Server::hasClientMessagesToSend(int clientFd) const {
    Client* client = const_cast<Server*>(this)->getClient(clientFd);
    return client ? client->hasMessagesToSend() : false;
}

// -------- TIMEOUT HANDLING --------

void Server::disconnectIdleClients(int timeoutSeconds) {
    std::vector<int> clientsToDisconnect;
    time_t currentTime = time(NULL);

    for (std::map<int, Client*>::iterator it = _clients.begin(); it != _clients.end(); ++it) {
        if (currentTime - it->second->getLastActive() > timeoutSeconds) {
            clientsToDisconnect.push_back(it->first);
        }
    }

    for (std::vector<int>::iterator it = clientsToDisconnect.begin(); it != clientsToDisconnect.end(); ++it) {
        std::cout << "Disconnecting idle client: fd=" << *it << std::endl;
        removeClient(*it);
    }
}

// -------- CHANNEL UTILITIES --------

std::vector<Channel*> Server::getClientChannels(Client* client) {
    std::vector<Channel*> clientChannels;
    
    for (std::map<std::string, Channel*>::iterator it = _channels.begin(); it != _channels.end(); ++it) {
        if (it->second->hasClient(client)) {
            clientChannels.push_back(it->second);
        }
    }
    
    return clientChannels;
}


============================================================
FILE: srcs/utils.cpp
============================================================
#include "utils.hpp"
#include <sstream>

namespace IRCUtils {
    std::vector<std::string> extractLines(std::string& buffer) {
        std::vector<std::string> lines;
        size_t pos = 0;

        while ((pos = buffer.find("\r\n")) != std::string::npos) {
            lines.push_back(buffer.substr(0, pos));
            buffer.erase(0, pos + 2);
        }

        return lines;
    }

    IRCMessage parseIRCMessage(const std::string& line) {
        IRCMessage msg;
        std::istringstream iss(line);
        std::string token;

        // Check for prefix
        if (line[0] == ':') {
            iss >> msg.prefix;
            msg.prefix = msg.prefix.substr(1); // Remove the ':'
        }

        // Get command
        iss >> msg.command;

        // Get parameters
        std::string param;
        while (iss >> param) {
            if (param[0] == ':') {
                // Trailing parameter - collect rest of line
                std::string trailing = param.substr(1);
                std::string rest;
                std::getline(iss, rest);
                if (!rest.empty()) {
                    trailing += rest;
                }
                msg.params.push_back(trailing);
                break;
            } else {
                msg.params.push_back(param);
            }
        }

        return msg;
    }

    std::string formatReply(int code, const std::string& target, const std::string& message) {
        std::ostringstream oss;
        oss << ":" << "irc.server.local" << " ";

        if (code < 100) oss << "0";
        if (code < 10) oss << "0";
        oss << code << " " << target << " " << message;

        return oss.str();
    }
}


============================================================
FILE: CLAUDE.md
============================================================
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is an IRC (Internet Relay Chat) server implementation written in C++. The project follows a traditional IRC protocol architecture with a complete command system and protocol implementation.

### Core Components
- **Server** (`Server.hpp/cpp`): Main server class managing clients and channels
- **Client** (`Client.hpp/cpp`): Represents connected IRC clients with authentication state and I/O buffering
- **Channel** (`Channel.hpp/cpp`): Manages IRC channels, membership, operators, and modes
- **CommandHandlers** (`CommandHandlers.hpp/cpp`): Implements all IRC command handlers
- **IRCProtocol** (`IRCProtocol.hpp/cpp`): Defines IRC numeric codes and protocol utilities

## Development Commands

### Building the Project
**IMPORTANT**: The Makefile is currently empty and needs implementation. When implementing:
- Use C++98 standard (typical for 42 School projects)
- Include standard targets: `all`, `clean`, `fclean`, `re`
- Object files should go in an `obj/` directory
- Final executable should be named `ircserv`

### Testing
- **Comprehensive test suite**: `test.cpp` with 27 test cases covering all core functionality
- **Helper function**: `printTest()` for consistent test result formatting
- **Test compilation**: Once Makefile is implemented, compile test with object files
- **Test execution**: Run the test executable to validate server functionality

## Architecture Overview

### Server-Client Architecture
The server uses file descriptor-based client management:
- `std::map<int, Client*> _clients` maps socket FDs to Client objects
- `std::map<std::string, Channel*> _channels` manages all channels
- All client operations are FD-based for network integration

### Client Lifecycle
1. **Connection**: `Server::addClient(int fd)` creates new Client with FD
2. **Authentication**: 3-step process (PASS → NICK → USER)
3. **Registration**: `Client::tryRegister()` completes after all auth steps
4. **Active**: Client can join channels and send messages
5. **Cleanup**: `Server::removeClient(int fd)` handles disconnection

### Channel Management
- **Creation**: `Server::createChannel()` returns existing or creates new
- **Membership**: `Channel::addClient()` / `Channel::removeClient()`
- **Broadcasting**: `Channel::broadcast()` sends to all members except sender
- **Auto-cleanup**: Empty channels are automatically deleted

### Message Flow
- **Input**: `Client::_inputBuffer` accumulates partial messages
- **Processing**: Command handlers parse and execute IRC commands
- **Output**: `Client::_outputBuffer` queues responses via `Server::queueMessage()`

## Command System

### Authentication Commands (CommandHandlers.hpp:22-24)
- `handlePass()`: Server password authentication
- `handleNick()`: Nickname selection with uniqueness validation
- `handleUser()`: Username and realname registration

### Communication Commands (CommandHandlers.hpp:26-31)
- `handleJoin()`: Channel joining with invite/key validation
- `handlePart()`: Channel leaving with optional message
- `handlePrivmsg()`: Private messages to users or channels
- `handleQuit()`: Client disconnection with broadcast

### Operator Commands (CommandHandlers.hpp:33-37)
- `handleKick()`: Remove users from channels (operators only)
- `handleInvite()`: Invite users to invite-only channels
- `handleTopic()`: Set/get channel topics
- `handleMode()`: Channel mode management (+i, +t, +k, +l, +o)

### IRC Protocol Implementation
- **Numeric replies**: Full RFC-compliant error codes in `IRCProtocol.hpp`
- **Message formatting**: `formatIRCMessage()` and `formatNumericReply()`
- **Validation**: Nickname and channel name validation functions

## Key Implementation Details

### Client Registration State Tracking
```cpp
// Client.hpp:13-16 - Registration flags
bool _receivedPass;  // PASS command received
bool _receivedNick;  // NICK command received  
bool _receivedUser;  // USER command received
bool _registered;    // All three completed
```

### Channel Modes System
```cpp
// Channel.hpp:17-21 - Mode flags
bool _inviteOnly;      // +i mode
bool _topicRestricted; // +t mode
std::string _key;      // +k mode (password)
size_t _userLimit;     // +l mode (0 = no limit)
```

### Invite System
- **Session-based**: `Channel::_invitedClients` set tracks invitations
- **Automatic cleanup**: Invites cleared when client joins or leaves
- **Operator-only**: Only channel operators can send invites

### Buffer Management
- **Input buffering**: Handles partial TCP packets in `Client::_inputBuffer`
- **Output buffering**: Queues messages for async sending in `Client::_outputBuffer`
- **Message queuing**: `Server::queueMessage(int fd, string)` appends to client buffer

## Testing Strategy

The test suite (`test.cpp`) provides comprehensive coverage:
- **Client Management**: Add/remove/lookup operations (Tests 1-7)
- **Channel Operations**: Creation, membership, operators (Tests 8-13)
- **Messaging**: Client queuing, channel broadcasting (Tests 14-16)
- **Cleanup**: Client removal, channel auto-deletion (Tests 17-23)
- **Stress Testing**: Multiple clients/channels, mass operations (Tests 24-25)
- **Edge Cases**: Empty server, invalid operations (Tests 26-27)

## Integration Points

### Network Layer Integration
The server is designed for easy network integration:
- All operations are FD-based
- Input/output buffers ready for async I/O
- Clean separation between protocol logic and network handling

### Missing Components
- **Makefile**: Build system implementation needed
- **Network I/O**: Socket creation, select/poll loop, actual data transmission
- **main.cpp**: Currently minimal, needs server startup logic

============================================================
FILE: main.cpp
============================================================
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <csignal>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
#include <poll.h>
#include <vector>
#include <cstring>
#include <cerrno>
#include <ctime>
#include "Server.hpp"
#include "utils.hpp"

// Global variables for signal handling
volatile sig_atomic_t g_shutdown = 0;
Server* g_server = NULL;

void signalHandler(int signal) {
    if (signal == SIGINT) {
        std::cout << "\nReceived SIGINT, shutting down gracefully..." << std::endl;
        g_shutdown = 1;
    }
}

void setupSignalHandling() {
    struct sigaction sa;
    sa.sa_handler = signalHandler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    if (sigaction(SIGINT, &sa, NULL) == -1) {
        perror("sigaction");
        exit(1);
    }
}

int createListeningSocket(int port) {
    int serverFd = socket(AF_INET, SOCK_STREAM, 0);
    if (serverFd == -1) {
        perror("socket");
        return -1;
    }

    // Set SO_REUSEADDR
    int opt = 1;
    if (setsockopt(serverFd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1) {
        perror("setsockopt SO_REUSEADDR");
        close(serverFd);
        return -1;
    }

    // Set non-blocking
    if (fcntl(serverFd, F_SETFL, O_NONBLOCK) == -1) {
        perror("fcntl O_NONBLOCK");
        close(serverFd);
        return -1;
    }

    // Bind
    struct sockaddr_in serverAddr;
    std::memset(&serverAddr, 0, sizeof(serverAddr));
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.s_addr = INADDR_ANY;
    serverAddr.sin_port = htons(port);

    if (bind(serverFd, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == -1) {
        perror("bind");
        close(serverFd);
        return -1;
    }

    // Listen
    if (listen(serverFd, SOMAXCONN) == -1) {
        perror("listen");
        close(serverFd);
        return -1;
    }

    std::cout << "Server listening on port " << port << std::endl;
    return serverFd;
}

void handleNewConnection(int serverFd, Server& server, std::vector<pollfd>& pollFds) {
    struct sockaddr_in clientAddr;
    socklen_t clientAddrLen = sizeof(clientAddr);

    // Accept all available connections
    while (true) {
        int clientFd = accept(serverFd, (struct sockaddr*)&clientAddr, &clientAddrLen);

        if (clientFd == -1) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                // No more connections to accept
                break;
            } else {
                perror("accept");
                break;
            }
        }

        // Set client socket non-blocking
        if (fcntl(clientFd, F_SETFL, O_NONBLOCK) == -1) {
            perror("fcntl client O_NONBLOCK");
            close(clientFd);
            continue;
        }

        // Add client to server
        server.addClient(clientFd);

        // Add to poll vector
        pollfd clientPollFd;
        clientPollFd.fd = clientFd;
        clientPollFd.events = POLLIN;
        clientPollFd.revents = 0;
        pollFds.push_back(clientPollFd);

        std::cout << "New client connected: fd=" << clientFd << std::endl;
    }
}

void handleClientRead(int clientFd, Server& server) {
    Client* client = server.getClient(clientFd);
    if (!client) {
        return;
    }

    char buffer[4096];
    ssize_t bytesRead = recv(clientFd, buffer, sizeof(buffer) - 1, 0);

    if (bytesRead <= 0) {
        if (bytesRead == 0) {
            std::cout << "Client disconnected: fd=" << clientFd << std::endl;
        } else if (errno != EAGAIN && errno != EWOULDBLOCK) {
            perror("recv");
        }
        // Client disconnected or error - will be handled in main loop
        return;
    }

    buffer[bytesRead] = '\0';
    client->appendToInputBuffer(std::string(buffer, bytesRead));

    // Process complete IRC lines
    while (client->hasCompleteLine()) {
        std::string line = client->extractNextLine();
        if (!line.empty()) {
            // TODO: For Protocol & Command Specialist - call command handler here
            // Example: processIRCCommand(clientFd, line, server);
            std::cout << "Received IRC line from fd=" << clientFd << ": " << line << std::endl;
        }
    }
}

void handleClientWrite(int clientFd, Server& server) {
    Client* client = server.getClient(clientFd);
    if (!client) {
        return;
    }

    // Flush queued messages to output buffer
    server.flushClientMessages(clientFd);

    std::string& outputBuffer = client->getOutputBuffer();
    if (outputBuffer.empty()) {
        return;
    }

    ssize_t bytesSent = send(clientFd, outputBuffer.c_str(), outputBuffer.length(), 0);

    if (bytesSent == -1) {
        if (errno != EAGAIN && errno != EWOULDBLOCK) {
            perror("send");
        }
        return;
    }

    // Remove sent bytes from buffer
    outputBuffer.erase(0, bytesSent);
}

void removeClientFromPoll(int clientFd, std::vector<pollfd>& pollFds) {
    for (std::vector<pollfd>::iterator it = pollFds.begin(); it != pollFds.end(); ++it) {
        if (it->fd == clientFd) {
            pollFds.erase(it);
            break;
        }
    }
}

void updatePollEvents(std::vector<pollfd>& pollFds, Server& server) {
    for (size_t i = 1; i < pollFds.size(); ++i) { // Skip server socket at index 0
        Client* client = server.getClient(pollFds[i].fd);
        if (client) {
            pollFds[i].events = POLLIN;
            // Add POLLOUT if there's data to send
            if (server.hasClientMessagesToSend(pollFds[i].fd)) {
                pollFds[i].events |= POLLOUT;
            }
        }
    }
}

int main(int argc, char* argv[]) {
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " <port> <password>" << std::endl;
        return 1;
    }

    int port = std::atoi(argv[1]);
    if (port <= 0 || port > 65535) {
        std::cerr << "Error: Invalid port number" << std::endl;
        return 1;
    }

    std::string password = argv[2];
    if (password.empty()) {
        std::cerr << "Error: Password cannot be empty" << std::endl;
        return 1;
    }

    // Setup signal handling
    setupSignalHandling();

    // Create listening socket
    int serverFd = createListeningSocket(port);
    if (serverFd == -1) {
        return 1;
    }

    // Create server instance
    Server server;
    server.setPassword(password);
    g_server = &server;

    // Setup poll vector
    std::vector<pollfd> pollFds;
    pollfd serverPollFd;
    serverPollFd.fd = serverFd;
    serverPollFd.events = POLLIN;
    serverPollFd.revents = 0;
    pollFds.push_back(serverPollFd);

    std::cout << "IRC Server started. Entering main loop..." << std::endl;

    // Variables for timeout handling
    time_t lastTimeoutCheck = time(NULL);
    const int TIMEOUT_CHECK_INTERVAL = 60; // Check every 60 seconds
    const int CLIENT_TIMEOUT = 300; // 5 minutes idle timeout

    // Main poll loop
    while (!g_shutdown) {
        // Update poll events for clients with data to send
        updatePollEvents(pollFds, server);

        // Check for idle clients periodically
        time_t currentTime = time(NULL);
        if (currentTime - lastTimeoutCheck >= TIMEOUT_CHECK_INTERVAL) {
            server.disconnectIdleClients(CLIENT_TIMEOUT);
            lastTimeoutCheck = currentTime;
        }

        // Poll with 100ms timeout
        int pollResult = poll(&pollFds[0], pollFds.size(), 100);

        if (pollResult == -1) {
            if (errno == EINTR) {
                // Interrupted by signal, continue
                continue;
            }
            perror("poll");
            break;
        }

        if (pollResult == 0) {
            // Timeout, continue
            continue;
        }

        // Check server socket for new connections
        if (pollFds[0].revents & POLLIN) {
            handleNewConnection(serverFd, server, pollFds);
        }

        // Check client sockets
        for (size_t i = 1; i < pollFds.size(); ) {
            int clientFd = pollFds[i].fd;
            short revents = pollFds[i].revents;

            // Check for errors or hangup
            if (revents & (POLLERR | POLLHUP)) {
                std::cout << "Client error/hangup: fd=" << clientFd << std::endl;
                close(clientFd);
                server.removeClient(clientFd);
                removeClientFromPoll(clientFd, pollFds);
                continue; // Don't increment i
            }

            // Handle read
            if (revents & POLLIN) {
                handleClientRead(clientFd, server);

                // Check if client disconnected
                Client* client = server.getClient(clientFd);
                if (!client) {
                    close(clientFd);
                    server.removeClient(clientFd);
                    removeClientFromPoll(clientFd, pollFds);
                    continue; // Don't increment i
                }
            }

            // Handle write
            if (revents & POLLOUT) {
                handleClientWrite(clientFd, server);
            }

            ++i;
        }
    }

    // Cleanup
    std::cout << "Shutting down server..." << std::endl;
    close(serverFd);

    // Close all client connections
    for (size_t i = 1; i < pollFds.size(); ++i) {
        close(pollFds[i].fd);
    }

    std::cout << "Server shutdown complete." << std::endl;
    return 0;
}


============================================================
FILE: Makefile
============================================================
NAME = ircserv

CXX = g++
CXXFLAGS = -Wall -Wextra -Werror -std=c++98 -Iincludes

SRCDIR = srcs
OBJDIR = objs
INCDIR = includes

SOURCES = main.cpp \
          $(SRCDIR)/Server.cpp \
          $(SRCDIR)/Client.cpp \
          $(SRCDIR)/Channel.cpp \
          $(SRCDIR)/Command.cpp \
		  $(SRCDIR)/CommandHandlers.cpp \
		  $(SRCDIR)/IRCProtocol.cpp \
          $(SRCDIR)/utils.cpp

OBJECTS = $(SOURCES:%.cpp=$(OBJDIR)/%.o)

all: $(NAME)

$(NAME): $(OBJECTS)
	$(CXX) $(CXXFLAGS) -o $(NAME) $(OBJECTS)

$(OBJDIR)/%.o: %.cpp
	@mkdir -p $(dir $@)
	$(CXX) $(CXXFLAGS) -c $< -o $@

clean:
	rm -rf $(OBJDIR)

fclean: clean
	rm -f $(NAME)

re: fclean all

.PHONY: all clean fclean re
